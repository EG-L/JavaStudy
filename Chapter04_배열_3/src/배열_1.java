/*
 *   1. 86page
 *   new => 메모리 확보
 *         --------- 메모리 크기 확인
 *             |
 *           메모리 주소를 전송
 *           => new를 사용할때 마다 메모리 주소가 달라진다.
 *   예) int[] arr = new int[5]; : new를 이용하면 자동 초기화(0)
 *     ------------------------
 *     arr           [0]    [1]    [2]    [3]    [4]
 *     ----       100-------------------------------
 *     100            0      0      0      0      0
 *     ----          -------------------------------
 *     메모리 주소를 이용해서 데이터를 제어 ==> 참조변수
 *                                   --------
 *                                   1. 배열
 *                                   2. 클래스
 *    => 데이터형의 형변환
 *    double[] arr= {10,20,'A','B',30}; 
 *    => arr[0] = 10.0;
 *       arr[1] = 20.0;
 *       arr[2] = 65.0;
 *       arr[3] = 66.0;
 *       arr[4] = 30.0;
 *       
 *    int[] arr = {10.0,'A','B',20,30}; => 오류
 *                -----
 *                
 *    boolean[] arr = {true,false,true...}
 *    
 *    데이터형[] 배열명;
 *            ------ 참조변수
 *    => 전체 크기(저장된 개수) => length
 *    => 데이터형[] 배열명 = new 데이터형[]; => 오류 발생
 *                           ------- 배열 크기 입력
 *       ------- 배열 크기 입력 시 오류
 *    
 *    => 복사
 *       얕은 복사 : 공유 (참조)
 *       깊은 복사 : 새로운 배열 생성
 *       
 *    
 *    int a = 10;
 *    int b = a;
 * */
public class 배열_1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//얕은 복사 => Call by Reference
		int[] arr = new int[5];
		// 0으로 초기화 => 연속적인 메모리 구조
		/* arr[0] => 일반 변수와 동일
		 * ---------------------------
		 *  0  |  0  |  0  |  0  | 0
		 * |---------------------------
		 *100        20byte
		 * */
		int[] arr2 = arr; //얕은 복사
		
		System.out.println(arr);
		System.out.println(arr2);
		arr[0] = 100;
		arr[1] = 200;
		//저장된 주소 값이 같은 경우에는 같은 메모리를 제어한다.
		//=> 얕은 복사 ==> 배열, 클래스
		
		System.out.println("arr2=>"+arr2[0]);
		System.out.println("arr2=>"+arr2[1]);
		// 같은 배열이나 클래스인 경우 같은 주소를 가지고 있으면 같은 메모리 제어
		//==> 얕은 복사
		// 메모리 주소가 틀린 경우 다른 메모리 제어

	}

}
