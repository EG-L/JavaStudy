package com.sist.main;
/*
 *     => 객체지향에 연연하지 말고..
 *     객체지향의 3대 특성 => 문법사항이 아니다.(권장사항)
 *     ---------------
 *     class Window extends JFrame => 재사용 => 상속 (is-a)
 *       => 변경 사항이 있는 경우
 *     class Window{
 *        JFrame fr = new JFrame(); => 재사용 => 포함(has-a) => 변경사항 없음
 *     }
 *     => 웹 / 스프링 => 상속이 거의 없다. => 포함
 *     
 *     1. 캡슐화 : 데이터 은닉화
 *               멤버변수 => private => 기능 설정을 통해서 접근
 *                                   --------
 *                                   멤버변수 : 저장/읽기
 *                                   ----------------
 *                                     |
 *                                   Getter/Setter
 *                데이터를 감추고 메소드를 통해서 접근하는 방식
 *     2. 상속 / 포함 : 기존의 클래스를 재사용
 *        상속
 *        ---
 *        1. 목적
 *          = 재사용 (신뢰성 , 개발속도)
 *          = 유지보수
 *          = 중복 제거
 *          = 통일성
 *          = 단점 : 실행속도가 늦다. (게임 => 자바X, C/C++(X), 어셈블러)
 *                 -------- 최적화 => exe (웹, 모바일)
 *                                      J2EE J2ME => J2SE
 *          = 장점 : 적은 양의 코드로 새로운 클래스를 작성
 *            class A => 1000줄
 *            {
 *             ----------
 *             ----------
 *             ----------
 *             ----------
 *            }
 *            
 *            class B extends A
 *            {
 *            }
 *            
 *            코드를 공통적으로 관리하기 때문에 여러 코드를 추가, 변경이 용이하다.
 *                                    -------------- ------------
 *                                      오버로딩          오버라이딩
 *            *** 자바는 오버라이딩 => 변경
 *                               ------
 *                                 | 프레임워크 ( 실제 소스 )
 *                               스프링 => 전자정부프레임워크(O)
 *                                    => 애니프레임워크
 *       2) 작성방법
 *         => 확장한다. => 기존의 클래스를 확장해서 새로운 클래스 제작
 *            extends
 *         => class Parent
 *            class Childe extends Parent
 *                        ---------
 *         => 단점 => 단일상속만 가능하다.
 *      3) 상속의 특징
 *         1. 생성자, 초기화 블록 상속이 안된다.
 *            상속받은 클래스 객체 생성 시 => 상속 내린 클래스 선 메모리 할당
 *            class A
 *            {
 *               int a,b;
 *               String s;
 *               -------------
 *               public A() => 자동추가
 *               {
 *               }
 *               -------------
 *            }
 *            class B extends A
 *            {
 *               int c,d;
 *               ------------- => 자동 추가
 *               public B()
 *               {
 *                  super(); => 상속받은 클래스의 생성자
 *               }
 *               -------------
 *            }
 *            
 *            B b = new B();
 *            
 *            Stack => 메모리에서 처리 (할당,해제)
 *            --b--
 *            
 *            -----    Heap => 실제 데이터 저장(프로그래머)
 *                  ----------
 *                   --Super--
 *                   --------
 *                      a
 *                   --------
 *                      b
 *                   --------
 *                      s
 *                   --------
 *                   --this--
 *                   --------
 *                      c
 *                   --------
 *                      d
 *                   --------
 *                  ----------
 *       => 모든 클래스의 상위 클래스 (최상위 클래스)
 *          => Object
 *       => private => 상속은 가능하지만 접근 불가
 *                                  -------- protected
 *       => 상속 => 상위 클래스 => super
 *                ---------- 
 *                 자신 클래스 => this
 *                ----------
 *       => 상속을 내리는 클래스 : 상속받는 클래스에 접근이 불가능
 *          상속을 받는 클래스 : 자신 + 상속내려진 클래스 접근 가능
 *                          this+super
 *     3. 다형성 => 필요시에
 *       => 변경해서 사용해야 된다. => 오버라이딩
 *       => 추가해서 사용하고 싶다. => 오버로딩
 *    [접근지정어] 리턴형 메소드명(매개변수)
 *    --------- ---- -------------
 *    {
 *    
 *    }
 *    ---------------------------------------------
 *            오버라이딩               오버로딩 => 기술면접(100%)
 *    ---------------------------------------------
 *    상태       상속                  같은 클래스
 *         => 상속없이 오버라이딩이 가능
 *         => 익명의 클래스
 *    메소드명   동일                   동일
 *    매개변수   동일                   매개변수가 다르다
 *    리턴형     동일                   관계없음
 *    접근지정어  축소(X),확대(O)          관계없음
 *         private< default < protected < public
 *         
 *         => 예)
 *              void aaa()
 *              
 *              => protected void aaa()
 *                 public void aaa()
 *              => 메소드는 다른 클래스와 연결
 *                 ---- public
 *        => Modify : 기존의 기능 변경, New => 새로운 기능 추가
 *        => 면접의 기술 => 정의를 내린다 => 부연
 *        => 객체지향프로그램의 객체란? 
 *                         => 현실세계를 특성화 => 추상화 => 단순화
 *                           --------------
 *    ---------------------------------------------
 *    상속 예외조건 => static : 공통으로 사용이 가능
 *                 생성자 / 초기화 블록
 *                 private : 상속은 된다 => 접근은 불가능하다.
 *    주의점)
 *          접근지정어
 *          클래스 => [접근지정어] class 클래스명
 *                   public => 다른 메모리 할당
 *          메소드 => [접근지정어] 리턴형 메소드명(매개변수(parameter))
 *                   public
 *          멤버변수 => [접근지정어] 데이터형 변수명
 *                    private / protected
 *          생성자 => [접근지정어] 클래스명()
 *                   public
 *          지역변수,매개변수 => 접근지정어를 사용 할 수 없다.
 *                           static 사용할 수 없다.
 *                           => final만 사용 가능 => 상수형 
 *          메소드
 *             멤버메소드 : static, 멤버변수를 사용할 수 있다.
 *             스태틱메소드 : static만 사용이 가능하다.
 *                 만약 멤버변수, 멤버메소드 사용 시 반드시 객체 생성 후 사용
 *             class A
 *             {
 *                private int a;
 *                static int b;
 *                public void aaa()
 *                {
 *                    a,b,bbb() 사용 가능
 *                }
 *                public static void bbb()
 *                {
 *                    b 사용 가능
 *                }
 *             }
 *          초기화블록 : 자동호출
 *             인스턴스블록
 *              {
 *                 static,멤버변수를 초기화
 *              }
 *             스태틱블록
 *              static
 *              {
 *                 static만 초기화
 *              }
 *          변수에 대한 초기화
 *            1) 명시적 초기화
 *                private int a = 10;
 *            2) 초기화 블록
 *                static변수 초기화
 *                => static은 생성자를 호출할 필요가 없다. => 자동 메모리 할당
 *            3) 생성자
 *                인스턴스변수 초기화
 *                => 인스턴스는 반드시 생성자 호출 해야 저장이 된다.
 *                => new 생성자()
 *                => 시작과 동시에 처리
 *                   윈도우 => 화면 설계
 *                   웹 => 자동 로그인 , 쿠키 읽기
 *                   일반 => 데이터베이스 연결, 서버연결 ...
 *            ------------- 클래스 영역은 선언만 가능 / 구현 불가능
 *            
 *          
 * */
class A
{
	int a;

	public A() {
		super(); //Object
	}
}
class B extends A
{
	int c;

	public B() {
		super();
	}
}
public class MainClass {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
	}

}
